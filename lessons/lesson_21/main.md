# Асинхронное программирование в Python

_https://leimao.github.io/blog/Python-Concurrency-High-Level/#Multiprocessing-VS-Threading-VS-AsyncIO-in-Python_

**_CPU-bound (привязанный к процессору)_**  
Примеры CPU-bound задач включают в себя вычисления научных моделей, обработку изображений и видео, а также сложные математические операции

**_I/O-bound (привязанный к вводу-выводу)_**  
Примеры I/O-bound задач включают в себя чтение/запись больших файлов, сетевые операции, работу с базами данных и другие операции, которые требуют много обращений к внешним источникам данных


**_Мультипроцессинг_** (multiprocessing) - это подход, позволяющий выполнять несколько процессов или задач одновременно на многоядерном процессоре или на нескольких физических процессорах. 
Отличается от многопоточности (multithreading), где несколько потоков выполняются внутри одного процесса.

**_AsyncIO (асинхронный ввод-вывод)_** - подход, который позволяет обрабатывать ввод-выводные операции без блокировки потока исполнения. 
Обычно используется в ситуациях, когда приложение выполняет много операций ввода-вывода, таких как чтение/запись файлов, сетевые запросы к удаленным серверам и т. д.

Вместо того, чтобы ждать завершения каждой операции ввода-вывода, асинхронное программирование позволяет приложению переключаться между разными задачами в процессе выполнения операций ввода-вывода. 
Это достигается с использованием концепции корутин или асинхронных функций, которые могут приостанавливаться и возобновляться в определенных точках без блокировки потока.

`async def func():` - не возвращает результат выполнения ф-ции, а создает объект нового типа
_Вызов асинхронной ф-ции:_
```python
if __name__ == "__main__":
    asyncio.run(main())
```

**_Карутина (coroutine)_** - специальный вид функции в Async, который может приостанавливаться и возобновляться в процессе выполнения без блокировки потока. 
Используются для организации параллельного выполнения нескольких асинхронных операций.

_Пример_
```python
res = await asyncio.gather(
    get_weather(),
    coro_currencies,
)
```

❗️В асинхронных функциях никогда не используем синхронный код (обычный sleep, with open ...)

Выставляем максимальное время выполнения нескольких асинк операций
Если выполнение операций занимает больше 3 секунд - выбрасывает asyncio.TimeoutError
```python
    async with asyncio.timeout(3):
        res = await asyncio.gather(
            get_weather(),
            coro_currencies,
        )
```  
*gather() устаревший подход, лучше использовать TaskGroup() в качестве контекстного менеджера

**_Как работать с файлами в асинхронном подходе_**  
_https://www.google.com/search?client=safari&rls=en&q=aiofiles&ie=UTF-8&oe=UTF-8_

```python
    async with asyncio.TaskGroup() as tg:
        task_get_weather = tg.create_task(get_weather())
        task_get_currencies = tg.create_task(coro_currencies)

    res_weather = task_get_weather.result()
    res_currencies = task_get_currencies.result()
```
Сначала выполнение всего, что в TaskGroup() и только потом остальной код

f-строчки НЕ ИСПОЛЬЗУЕМ в асинхронном подходе, так как они требуют время для форматирования
Также может быть разный уровень логирования и мы делаем форматирование того, что не нужно форматировать